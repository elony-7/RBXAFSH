local TeleportSpecificModule2 = {}

TeleportSpecificModule2.Locations = {
    ["location1"]   = Vector3.new(-0.2, 2061.7, -100.1),
    ["location1-2"] = Vector3.new(-1.9, 2061.7, -98.6),
    ["location1-3"] = Vector3.new(-6.1, 2061.7, -104.7),
    ["location1-4"] = Vector3.new(4.0, 2061.7, -100.7),
    ["location1-5"] = Vector3.new(0.8, 2061.7, -102.6)
}

local OrderedNames = {}
for name in pairs(TeleportSpecificModule2.Locations) do
    table.insert(OrderedNames, name)
end
table.sort(OrderedNames)

local CachedCFrames = {}
for name, vec in pairs(TeleportSpecificModule2.Locations) do
    CachedCFrames[name] = CFrame.new(vec)
end

local running = false
local hb = nil

local TELEPORT_INTERVAL = 0.02
local SMOOTHNESS = 0.55

function TeleportSpecificModule2.Start()
    if running then return end
    running = true

    local index = 1
    local total = #OrderedNames
    local player = game.Players.LocalPlayer
    local timeAccum = 0

    hb = game:GetService("RunService").Heartbeat:Connect(function(dt)
        if not running then return end
        timeAccum += dt

        if timeAccum < TELEPORT_INTERVAL then
            return
        end
        timeAccum = 0

        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")

        if hrp then
            local target = CachedCFrames[OrderedNames[index]]

            -- smooth toward
            hrp.CFrame = hrp.CFrame:Lerp(target, SMOOTHNESS)

            -- final exact snap (this triggers the server script!)
            task.wait(0.001)
            hrp.CFrame = target

            hrp.AssemblyLinearVelocity = Vector3.zero
            hrp.AssemblyAngularVelocity = Vector3.zero
        end

        index += 1
        if index > total then
            index = 1
        end
    end)
end

function TeleportSpecificModule2.Stop()
    running = false
    if hb then hb:Disconnect() hb = nil end
end

return TeleportSpecificModule2
